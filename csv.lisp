(in-package :csv)
(defun make-escapep (prev curr)
  (char= #\" prev curr))
(defun end-tokenp (prev curr)
  (declare (ignore curr))
  (char= #\" prev))
(defun openp (prev curr)
  (declare (ignore curr))
  (char= #\" prev))
(defun str->list (str)
  (labels ((inner (str acc len)
             (if (= 0 len)
                 (nreverse acc)
                 (inner (subseq str 1) (cons (elt str 0) acc) (1- len)))))
    (inner str nil (length str))))
(let ((in nil)
      (escape nil))
  (setf (fdefinition 'switches)
	(lambda (prev curr str)
	  (let ((str (if (array-has-fill-pointer-p str)
                         str
                         (make-array (length str)
                                     :fill-pointer 0
                                     :adjustable t
                                     :element-type 'character
                                     :initial-contents (str->list str)))))
            (if (null curr)
	        (progn (setf in nil escape nil) str)
	        (if in
		    (if escape
		        (progn (toggle escape) (push-on prev str))
		        (if (make-escapep prev curr)
			    (progn (toggle escape) str)
			    (if (end-tokenp prev curr)
			        (progn (toggle in) (push-on #\Nul str))
			        (push-on prev str))))
		    (if (openp prev curr)
		        (progn (toggle in) str)
		        str)))))))
(defun splice (str)
  (labels ((inner (str acc!)
             (if (string= "" str)
                 (nreverse acc!)
                 (let ((res (search (string #\Nul) str)))
                   (inner (subseq str (1+ res)) (push (subseq str 0 res) acc!))))))
    (inner str nil)))
(make-reader my-csv (stream #\# #\!)
  (macrolet ((once (&body body) ``',,@body))
    (do ((prev #1= (read-char stream nil nil) curr)
	 (curr #1# #1#)
	 (str (make-array 0 :adjustable t :element-type 'character)
	      (switches prev curr str)))
	((and (char= curr #\#)
              (char= prev #\!)) (once (splice (switches nil nil str)))))))
(defun read-to-string (stream)
  (with-output-to-string (s)
    (dolines (line stream)
      (princ line s)
      (format s "~%"))))
(defun slurp-csv (path)
  "Read in a CSV file to string. Resource intensive."
  (with-open-file (s path)
    (concatenate 'string "#!" (read-to-string s) "!#")))
(defun dequote (list)
  (if (eql 'quote (car list))
      (cadr list)
      list))
(defun slurp (path)
  "Read in a CSV file to list. Resource intensive."
  (dequote (read-from-string (slurp-csv path))))
